1.CSS:

/* 度相同的r候後覆w前*/
/* class 序以style 中橹*/
/* inline >#id>.class >type > inherit*/
--
function:

1.

//arguemts[] : key  String 
在函式炔自有告arguments名Q⒖贾辆哧列外^的物件
arguments[i]
arguments.length
arguments不是Array例，它只是具有底肿樘匦裕特性⒖贾魅氲囊担K具有length特性代表魅胍档怠

2.
function default return : undefined;

3.
var output="";
var ar = new Array(2,4,6,8,9);
ar[8]="cat";
output="ar:"+ar +"<br>";
output+="splice els:"+ar.splice(1,2) +"<br>"; // start from1 ,delete 2 items
output+="ar:"+ar+"<br>";
output+="splice els:"+ar.splice(1,0,"dog",10000) +"<br>"; // start from1 ,delete 2 items
output+="ar:"+ar+"<br>";


----
Constructor 
http://openhome.cc/Gossip/JavaScript/Constructor.html

1.
每透^new建的物件，都有constructor特性，⒖贾廉初建它的函式。例如：
js> function Person() {}
js> var p = new Person();
js> p.constructor == Person
true


function Person(name, age)
	{
		this.age = age;
		this.name =name;
		this.toString = function (){ return this.name+":"+this.age; };
		//return this;	}
var p = {};
Person.call(p, 'Justin', 35); // p.constructor != Person // p.constructor = function Object

2.

Person2.call(p2,"Subrina",25); 
		console.log(p2.getName()+":"+p2.getAge()+"\n");	

function Person2(name, age)
	{
		this.getName = function(){return name;}; //closure
		this.getAge = function(){return age;};
		this.toString = function (){ return this.name+":"+this.age; };
		//return this;	
	}



上例中，在物件上新增了getName特性，⒖贾烈函式，函式形成]包定了name，狄簿褪^域担K非物件上的特性，所以o法透^ . \算子取得，因此模M了私用性。


3.
function Accounts(){
		var balance=0;
		this.setBalance= function(money){
			 if(money <0 ){throw new Error('money cannot be negative');};
			 		balance= money; };	
					
		this.getBalance = function() {
          return balance;
       };
	}

	p2 = new Accounts();
	p2.setBalance(100);
	console.log(p2.getBalance()+":"+p2.balance+"\n");  // p2.balance==undefined , p2.getBalance():100;


-----
@Prototype
http://openhome.cc/Gossip/JavaScript/Prototype.html

1.
function Person(name, age) {
    this.name = name;
    this.age = age;
    this.toString = function() {
        return '[' + this.name + ', ' + this.age + ']';
    };
}

//p1.toString == p2.toString : false

Person函式中使用了函式字建立函式例，K指定otoString特性，每一次呼叫建式r，都建立一次函式例：


2.
但函式热K]有定特定Y源。榱斯省w，你也S可以@N撰：
function toString() {
    return '[' + this.name + ', ' + this.age + ']';
}

function Person(name, age) {
    this.name = name;
    this.age = age;
    this.to

3.@可以解Q重}建立函式例的}，但在全域（物件）上多了toString名Q。如果你知道函式在定xr，都有prototype特性，t可以如下：

	Person.prototype.toString = function (){
		return this.name+":"+this.age+"\n";};
		
		p1 = new Person('Justin', 35);
		p2 = new Person('Momor', 32);

4.使用newPI字r，JavaScript先建立一空物件，接著O定物件的原型楹式的prototype特性所⒖嫉奈锛，然後呼叫建式K⑺建立的空物件Othis。

5.你可以在任何rgc函式的prototype新增特性，由於原型查找的C制，透^函式而建的所有例，都可以找到特性，即使例建立之後，特性才被添加到原型中。例如：
	js> function Some() {}
js> var s = new Some();
js> print(s.data);
undefined
js> Some.prototype.data = 10;
10
js> print(s.data);
10

6. 物件的原型是在建立物件之後就_立下淼模所以在@行：
var sportsCar = new SportsCar();
sportsCar就被指定了原型物件，也就是r的SportsCar.prototype所⒖嫉奈锛，AO就是具有一constructor特性 的Object例


sportsCar.doors

http://openhome.cc/Gossip/JavaScript/ClassSimulation.html


var Class = {};
Class.create = function(methods) {
    var Clz = methods.initialize;
    for(var mth in methods) {
        if(mth != 'initialize') {
            Clz.prototype[mth] = methods[mth];
        }
    }
    return Clz;
};

那N你就可以@N使用：
var Circle = Class.create({
    initialize : function(x, y, r) { // 作榻式
        this.x = x;
        this.y = y;
        this.r = r;
    },
    area : function() {
        return Math.PI * Math.pow(this.r, 2);
    },
    toString : function() {
        var text = [];
        for(var p in this) {
            if(typeof this[p] != 'function') {
                text.push(p + ':' + this[p]);
            }
        }
        return '[' + text.join() + ']';
    }
});
var circle = new Circle(10, 10, 5);

如果想封be的^承，t可以@N作：
Class.extend = function(Superclz, methods) {
    var Subclz = this.create(methods);
    var subproto = Subclz.prototype;
    Subclz.prototype = new Superclz();
    for(var p in Subclz.prototype) {
        if(Subclz.prototype.hasOwnProperty(p)) {
            delete Subclz.prototype[p];
        }
    }
    Subclz.prototype.constructor = Subclz;
    for(var p in subproto) {
        Subclz.prototype[p] = subproto[p];
    }
    return Subclz;
};

例如，想^承先前建立的Circle，t可以如下：
var Cylinder = Class.extend(Circle, {
    initialize : function(x, y, r, h) {
        Circle.call(this, x, y, r);
        this.h = h;
    },
    volumn : function() {
        return this.area() * this.h;
    }
});
var cylinder = new Cylinder(10, 10, 5, 15);

以上H是e模M的概念，至於想要模M到什N程度，或者是想_到什N拥娘L格，其有各N的O方式。


6.


7----HTML DOM 

(a)
txt = xmlDoc.getElementsByTagName("title")[0].childNodes[0].nodeValue;


<script>
var xhttp = new XMLHttpRequest();
xhttp.onreadystatechange = function() {
    if (this.readyState == 4 && this.status == 200) {
    myFunction(this);
    }
};
xhttp.open("GET", "books.xml", true);
xhttp.send();

function myFunction(xml) {
    var xmlDoc = xml.responseXML;
    document.getElementById("demo").innerHTML =
    xmlDoc.getElementsByTagName("title")[0].childNodes[0].nodeValue;
}
</script>

(b)核心API文件中所有热荻家楣c
Node
   |Document
   |Element
   |Text
   |Attr

(c)


